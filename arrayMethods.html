<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    
</body>

<script>
    // Write the function camelize(str) that changes dash-separated words like “my-short-string” into camel-cased “myShortString”.
// That is: removes all dashes, each word after dash becomes uppercased.

function camelize(str){
    return str .split('-')
    .map((word, index) => index === 0? word: word[0].toUpperCase() + word.slice(1) )
    .join('');
}

function filterRange(arr, a, b){
    return arr.filter(item => item >= a && item <= b);
}
// alert(camelize('list-style-image'));
let arr = [5, 3, 8, 1, 9, -10];

let filtered = filterRange(arr, 1, 4);
// alert( filtered );
// alert(arr)


// Write a function filterRangeInPlace(arr, a, b) that gets an array arr and removes from it all values except those that are between a and b. The test is: a ≤ arr[i] ≤ b.
// The function should only modify the array. It should not return anything.

function filterRangeInPlace(arr, a, b){
    
    for(i = 0; i < arr.length; i++){
        let val = +arr[i];

        if(val < a || val > b){
            arr.splice(i, 1);
            i--;
        }
    }
}

// filterRangeInPlace(arr, 1, 3);
// alert(arr)

arr.sort((a, b) => b - a);
// alert(arr);

function copySorted(arr){
    return [...arr].sort();
}

let arr2 = ["HTML", "JavaScript", "CSS"];

let sorted = copySorted(arr2);

// alert( sorted );
// alert( arr2 );


function Calculator(){
    this.methods = {
        '+': (a, b) => a + b,
        '-': (a, b) => a - b,
    }

    this.calculate = function(str){
        let part = str.split(' ');

        a = +part[0];
        operator = part[1];
        b = +part[2];

        if(!this.methods[operator] || isNaN(a) || isNaN(b)) return NaN;

        return this.methods[operator](a, b);
    }

    this.addMethods = function(name, func){
        return this.methods[name] = func;
    }
}

let cal = new Calculator();

cal.addMethods('*', (a, b) => a * b);
cal.addMethods('**', (a, b) => a ** b);
cal.addMethods('/', (a, b) => a / b);
// alert(cal.calculate("15 / 15"));


// You have an array of user objects, each one has user.name. Write the code that converts it into an array of names.
let abdul = { name: "Abdul", age: 21 };
let sule = { name: "Suleiman", age: 16 };
let aisha = { name: "Aisha", age: 11 };

let users = [ abdul, aisha, sule ];

let names = users.map(item => item.name);

// alert(names);


// You have an array of user objects, each one has name, surname and id.
// Write the code to create another array from it, of objects with id and fullName, where fullName is generated from name and surname.
let abdulS = { name: "Abdul", surname: "Samad", id: 1 };
let suleiman = { name: "Suleiman", surname: "Muhammad", id: 2 };
let aishat = { name: "Aishat", surname: "Muhammad", id: 3 };

let users1 = [ abdulS, suleiman, aishat ];

let usersMapped = users1.map(item => (
    {
        fullName: item.name + " " + item.surname,
        id: item.id
    }
))

// alert( usersMapped[0].id )
// alert( usersMapped[0].fullName )


// Write the function sortByAge(users) that gets an array of objects with the age property and sorts them by age.
// Using the top users array

function sortByAge(arr){
    return arr.sort((a, b) => a.age - b.age)
}

let sortedArray = sortByAge(users);

alert(sortedArray[2].name)

// All element orders should have an equal probability. For instance, [1,2,3] can be reordered as [1,2,3] or [1,3,2] or [3,1,2] etc, with equal probability of each case.

function shuffle(arr){
    arr.sort(() => Math.random() - 0.5);
}

let array = [1,2,3];

shuffle(array);
alert(array)
</script>
</html>